unit stringUTILL;
interface
	const
		maxElementLength = 20;
	type
		aLineElementLength = string[maxElementLength];
		aLines = ^aStripe;
		aStripe = record
				aElement: aLineElementLength;
				next: aLines
			end;		{end of POINTER aLines}
		ErrorType = (NoError, LessLeftP, StackIsFull);
		SourceTextPointer = ^SourceText;
		SourceText = record
				strip: aLines;
				validity: boolean;
				error: ErrorType;
				next: SourceTextPointer
			end;		{end of POINTER SourceTextPointer}

{SpritRoad will road content of text file into linked list}
{when text in one line is more than maxElementLength length, it will split line into}
{pieces which each length is equal to maxElementLength}
	procedure SpritRoad (var aMyLink: SourceTextPointer; var aSourceText: text);
{********************************************************************}

implementation
	procedure SpritRoad (var aMyLink: SourceTextPointer; var aSourceText: text);
		var
			taMyLink: SourceTextPointer;
			myCtr: integer;
			chElement: char;
			myElementLine: aLineElementLength;
	begin
		taMyLink := aMyLink;
		myCtr := 0;
		myElementLine := '';
		while (myCtr <= maxElementLength) or (not eoln(aSourceText)) do
			begin
				myCtr := myCtr + 1;
				readln(aSourceText, chElement);
				myElementLine := concat(myElementLine, chElement);
			end;				{end of while not eoln}

		taMyLink^.strip^.aElement := myElementLine;
		taMyLink^.strip^.myCtr := 0;

	end;				{end of spritroad}

{********************************************************************}
end.				{end of unit}