unit MathCalc;	{Mathematical Calculation Unit}

interface
	const
		Capa = 50;
		LimitAve = 20;	{limet number-number of variables to be averaged}
	type
		ArrType = array[1..Capa] of real;
		AveArr = array[1..LimitAve] of integer;

	procedure Maxin (var Max, Min: real; Rail: ArrType; NumericChaser: integer);		{evaluate max and min numbers}
	procedure Average (var SigmaX: real; var Xave: real; Xrail: ArrType; NumericChaser: integer);
		{this procedure Average only goes with SDnA-standard diviation-returns SigmaX to procedure SDnA}
	procedure SDnA (var Ave, StdDiv: real; Rail: ArrType; NumericChaser: integer);		{calculate standard diviation and average in the sametime}
		{this procedure has to be used with procedure Average, it has to receive value from Average}
	procedure Averager (var Ave: real; Arr: AveArr; Num: integer);

implementation
	procedure Maxin (var Max, Min: real; Rail: ArrType; NumericChaser: integer);
		var
			i: integer;	{counter for for loop}
	begin
		Max := Rail[1];
		Min := Rail[1];
		for i := 1 to NumericChaser do
			begin
				if Rail[i] > Max then
					Max := Rail[i];
				if Rail[i] < Min then
					Min := Rail[i]
			end
	end;		{end procedure evaluating max and Min-Maxin}

	procedure Average (var SigmaX: real; var Xave: real; Xrail: ArrType; NumericChaser: integer);
		var
			i: integer;{counter}
			TotNum: real;{total numbers}
	begin
		TotNum := 0;
		SigmaX := 0;
		for i := 1 to NumericChaser do
			begin
				TotNum := TotNum + Xrail[i];
				SigmaX := SigmaX + Xrail[i] * Xrail[i]
			end;
		Xave := TotNum / NumericChaser
	end;		{end procedure getting standard diviation-GetS}

	procedure SDnA (var Ave, StdDiv: real; Rail: ArrType; NumericChaser: integer);
		var
			SigmaX: real;
			Bket: real;
	begin
		Bket := 0;
		Average(SigmaX, Ave, Rail, NumericChaser);
		Bket := SigmaX - NumericChaser * Ave * Ave;
		StdDiv := SQRT(Bket / (NumericChaser - 1))
	end;		{end procedure solution of standard diviation-SDnA}
				{calles procedure Average, so getting average in the same time}
end.		{end of unit -MathCalc}