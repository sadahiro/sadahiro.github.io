unit ListADT;
{Programmer:	Makoto Sadahiro }
{starting date: Nov 9th '93}
{last modified date:  Nov 10th '93}

{LINKED list implimentation}
{the build order: listype->listADT->calling program}

interface
	uses
		time, LisType;
	type
{ListType}
		PointerType = ^NodeType;
		NodeType = record
				Info: ListElementType;				{in unit listype}
				Next: PointerType				{pointer to next node}
			end; (* NodeType *)
		IndexType = PointerType;
		ListType = PointerType;				{declaration}
{*****************************}

	procedure CreateList (var List: ListType);
  (* Creates list in empty state. *)
  {POST:  List exists and is Empty }
	function EmptyList (List: ListType): Boolean;
  (* Returns True if List is empty; returns False otherwise. *)
  {PRE:  List exists }
  {POST:  EmptyList = (list is empty)}
	function FullList (List: ListType): Boolean;
  {PRE:  List exists}
  {POST:  Always returns FALSE }
	procedure DestroyList (var List: ListType);
  (* Destroys all list elements, leaving List empty. *)
  {PRE:  List exists }
  {POST: List is empty }
	procedure RetrieveElement (List: ListType; KeyValue: KeyType; var Element: ListElementType; var Found: Boolean);
{PRE:  List exists }
{POST: Found = (element with key of KeyValue exists in the List)  }
{If Found , Element = a copy of the element from the list with Key equal to KeyValue .}
{If NOT found , Element is undefined . The list is UNCHANGED . }
	procedure ModifyElement (var List: ListType; ModElement: ListElementType);
{PRE: Element with key matching ModElement key exists in the list }
{POST: List is the original list with ModElement replacing the element with the matching key . }
	procedure InsertElement (var List: ListType; NewElement: ListElementType);
{PRE:  List is not full. NewElement is not in the list . }
{POST: List is the original list plus NewElement. }
	procedure DeleteElement (var List: ListType; DeleteVal: KeyType);
{PRE: An element with key of DeleteVal exists in the list. }
{POST: List is the original list with the element with the DeleteVal removed key removed . }
{*****************************}

implementation
{*****************************}

	procedure CreateList (var List: ListType);
	begin (* CreateList *)
		List := nil
	end;  (* CreateList *)
{*****************************}

	function EmptyList (List: ListType): Boolean;
  (* Returns True if List is empty; returns False otherwise. *)
	begin (* EmptyList *)
		EmptyList := (List = nil)
	end;  (* EmptyList *)
{*****************************}

	function FullList (List: ListType): Boolean;
  (* Stub for FullList operation, which is meaningless in *)
  (* this implementation.                                 *)
	begin (* FullList *)
		FullList := False
	end;  (* FullList *)
{*****************************}

	procedure DestroyList (var List: ListType);
  (* Destroys all list elements, leaving List empty. *)
		var
			TempPtr: PointerType;
	begin (* DestroyList *)
  (* Remove all elements from the list, freeing the space. *)
		while List <> nil do
			begin
      (* Unlink the first node from the list. *)
				TempPtr := List;
				List := List^.Next;
      (* Free the space from the node. *)
				Dispose(TempPtr)
			end (* WHILE *)
	end;  (* DestroyList *)
{*****************************}

(***************************************************************)
(*    This is a HIDDEN procedure, used only within this unit   *)
(***************************************************************)
	procedure FindElement (List: ListType; KeyValue: KeyType; var Location: PointerType; var PredLoc: PointerType);
  (* IF KeyValue is found in list, then Location = pointer  *)
  (* to the node with key KeyValue and PredLoc = pointer to *)
  (* the preceding list node. If KeyValue is found in the   *)
  (* first node, PredLoc = NIL. IF KeyValue is not found in *)
  (* a list node, then Location = NIL and PredLoc = pointer *)
  (*  to the list node that is the logical predecessor of a *)
  (* node with the key KeyValue.                            *)
		var
			MoreToSearch: Boolean;
	begin (* FindElement *)
  (* Set up to search. *)
		Location := List;         (* start of list *)
		PredLoc := nil;
		MoreToSearch := True;
  (* Search for node containing KeyValue until:      *)
  (*   (1) we reach KeyValue's place in the list, or *)
  (*   (2) we reach the end of the list.             *)
		while MoreToSearch and (Location <> nil) do
			if Location^.Info.Key < KeyValue then (* keep looking -- advance both pointers *)
				begin
					PredLoc := Location;
					Location := Location^.Next
				end (* Key(Location) < KeyValue *)
			else
				MoreToSearch := False;
  (* If Location does not point to a node containing  *)
  (* KeyValue, reset Location to NIL.                 *)
		if Location <> nil then
			if Location^.Info.Key <> KeyValue then
				Location := nil
	end; (* FindElement *)
{*****************************}

	procedure RetrieveElement (List: ListType; KeyValue: KeyType; var Element: ListElementType; var Found: Boolean);
  (* IF Found the Element with key KeyValue is returned;  *)
  (* otherwise, Element is undefined.                     *)
		var
			Location: PointerType; (* points to node with KeyValue *)
			Ignore: PointerType; (* n/a to this operation        *)
	begin (* RetrieveElement *)
  (* Find Location of KeyValue in List. Returns NIL value for *)
  (* Location if the key was not found in the list.           *)
		FindElement(List, KeyValue, Location, Ignore);
		Found := (Location <> nil);
		if Found then
			Element := Location^.Info
	end;  (* RetrieveElement *)
{*****************************}

	procedure ModifyElement (var List: ListType; ModElement: ListElementType);
  (* Replace the list element with ModElement.Key with the *)
  (* new value of ModElement. Assumes that this element    *)
  (* exists in List.                                       *)
		var
			Location: PointerType; (* points to node to modify *)
			Ignore: PointerType; (* n/a to this operation    *)
	begin (* ModifyElement *)
  (* Find Location of ModElement's key in List. *)
		FindElement(List, ModElement.Key, Location, Ignore);
  (* Modify the element values. *)
		Location^.Info := ModElement
	end;  (* ModifyElement *)
{*****************************}

	procedure InsertElement (var List: ListType; NewElement: ListElementType);
  (* Add NewElement to List, leaving key value-ordered *)
  (* structure of List intact. Assumes that an element *)
  (* with same key is not already in the list.         *)
		var
			NewNode: PointerType; (* pointer to the new node *)
			PredLoc: PointerType; (* ptr to preceding node   *)
			Ignore: PointerType; (* not used                *)
	begin (* InsertElement *)
  (* Find the insert location. *)
		FindElement(List, NewElement.Key, Ignore, PredLoc);
  (* Allocate a new node, and put NewElement into it. *)
		New(NewNode);
		NewNode^.Info := NewElement;
  (* Insert the new node into the list. *)
		if PredLoc = nil then (* list is empty OR inserting at beginning of list *)
			begin
				NewNode^.Next := List;
				List := NewNode
			end (* inserting first element *)
		else (* inserting in the middle or at the end *)
			begin
				NewNode^.Next := PredLoc^.Next;
				PredLoc^.Next := NewNode
			end (* inserting in middle or at end *)
	end; (* InsertElement *)
{*****************************}

	procedure DeleteElement (var List: ListType; DeleteVal: KeyType);
  (* Removes the node containing the key DeleteVal from    *)
  (* the linked list pointed to by List. Assumes that this *)
  (* key is present in the list.                           *)
		var
			Location: PointerType;  (* points to delete node    *)
			PredLoc: PointerType;  (* points to preceding node *)
	begin (* DeleteElement *)
  (* Find the element to delete. On return from this  *)
  (* procedure, Location points to the node to delete *)
  (* and PredLoc points to the node preceding it, or  *)
  (* is NIL if we're deleting the first node in list. *)
		FindElement(List, DeleteVal, Location, PredLoc);
  (* Unlink the delete node from the list. *)
		if PredLoc = nil then (* deleting the first or only node *)
			List := Location^.Next
		else (* deleting a middle or end node *)
			PredLoc^.Next := Location^.Next;
  (* Free the node space to be reused. *)
		Dispose(Location)
	end; (* DeleteElement *)
{*****************************}

{*************************************}
end.  {unit ListADT}