unit Ledit;
{Programmer:	Makoto Sadahiro }
{starting date: Nov 22nd '93}
{last modified date:  Nov 22nd '93}

{all procedures for editing functioning}
interface
	uses
		IOOC, time, listype, ListADT;

	var
		done, there: boolean;
		newId: integer;
		Sname: str255;
		out: char;
		StuLog: ListElementType;

{AddOn is used to add student who is either on log or not on log}
	procedure AddOn (var List: ListType);
	{out: List with new student}
	{post: list has new student added}
{DropOff is used to eliminate a student}
	procedure DropOff (var List: ListType);
	{pre: list is not empty}
	{post: students eliminated}
{Sign is used to sign student in and out}
	procedure Sign (var List: ListType);
	{in:list}
	{out: list with modified}
	{post: list modified}
{WReList is used to reset weekly}
	procedure WReList (var List: ListType);
	{in:list}
	{out: list with modified}
	{post: list modified}
{****************************************************************}

implementation

	procedure AddOn (var List: ListType);
	begin
		done := false;
		while not done do
			begin
				write('type in ID to be added>');
				readln(newID);
				RetrieveElement(List, NewId, StuLog, there);
				if there then
					begin
						StuLog.MaxHr := StuLog.MaxHr + DefHr;
						ModifyElement(List, StuLog);
					end		{if there then}
				else
					begin
						write('type in student neme-first then last neme>');
						readln(Sname);
						with StuLog do
							begin
								key := NewId;
								name := Sname;
								validity := true;
								maxHr := defHr;
								usdHr := 0;
								remHr := maxHr - usdHr;
								penalty := false;
								atstatus := false;
							end;		{with StuLog do}
						InsertElement(List, StuLog);
					end;		{if there else}
				writeln('student with ID ', newID, ' added...');
				write('are you done?>');
				readln(out);
				if (out = 'y') or (out = 'Y') then
					done := true;			{if not Y,y then repeat}
			end;		{while not done}
		writeln;
		writeln('returning to base menu.....');
		writeln;
	end;		{AddOn}
{*****************************}

	procedure DropOff (var List: ListType);
	begin
		done := false;
		while not done do
			begin
				write('type in ID to be dropped>');
				readln(newID);
				RetrieveElement(List, NewId, StuLog, there);
				if there then
					begin
						if StuLog.maxHr > 300 then		{case student is registered for more then 2 classes}
							begin
								StuLog.maxHr := StuLog.maxHr - 300;
								if Stulog.maxHr < StuLog.usdHr then
									Stulog.validity := false;
								ModifyElement(List, Stulog);
								writeln('student ID ', NewID, ' dropped...');
								writeln(' maximum access hour still remaining..');
							end		{if stulog.maxHr>300 then}
						else
							begin
								DeleteElement(List, NewID);
								writeln('student ID ', NewID, ' dropped...');
							end;		{if stulog.maxHr>300 else}
					end		{if there then}
				else
					begin
						writeln('student ID ', NewID, ' can not found...');
					end;		{if there else}
				write('are you done?>');
				readln(out);
				if (out = 'y') or (out = 'Y') then
					done := true;			{if not Y,y then repeat}
			end;		{while not done}
		writeln;
		writeln('returning to base menu.....');
		writeln;
	end;			{DropOff}
{**************************************************}

{sign in is used to sign in a student}
	procedure SignIn (var List: ListType);
	{in: list}
	{out:list}
	{post:list modified}
		var
			aStudent: ListElementType;
			there: boolean;
			rem: integer;
	begin
		write('SignIn:type in student ID to be signed in>');
		readln(aStudent.key);
		RetrieveElement(List, aStudent.key, aStudent, there);
		if there then
			begin
				if aStudent.validity then
					begin
						if aStudent.atstatus then
							writeln('ID# ', aStudent.key, ' already signed in')
						else
							begin
								aStudent.atstatus := true;
								write('type in hour in 2 digits>');
								readln(aStudent.SinTime.hour);
								write('type in minute in 2 digits>');
								readln(aStudent.SinTime.minute);
								writeln('ID# ', aStudent.key, ' signed in at ', aStudent.SinTime.hour : 2, ':', aStudent.SinTime.minute : 2);
								rem := convertToHr(aStudent.remHr);
								write('the remainning hour is ', rem div 100 : 3, 'hours' : 6, 'and' : 4);
								if (rem mod 100) = 0 then
									write('00' : 3)
								else
									write(rem mod 100 : 3);
								writeln('hours' : 6);
								modifyElement(List, aStudent);
							end;		{if aStudent.atstatus else}
					end		{if aStudent.atstatus}
				else
					begin
						writeln('ID# ', aStudent.key, ' is not valid');
						if aStudent.penalty then
							writeln('maximum hour already exceeded')
						else
							writeln('the reason unknown');
					end;		{if aStudent.atstatus else}
			end		{if there then}
		else
			begin
				writeln('the ID not found....');
			end;		{if there else}
	end;		{signIn}
{*****************************}

{sign out is used to sign out a student}
	procedure SignOut (var List: ListType);
	{in: list}
	{out:list}
	{post:list modified}
		var
			aStudent: ListElementType;
			there: boolean;
			timeIn, timeOut: integer;
	begin
		write('SignOut:tyupe in student ID to be signed out>');
		readln(aStudent.key);
		RetrieveElement(List, aStudent.key, aStudent, there);
		if there then
			begin
				if aStudent.atstatus then
					begin
						write('type in hour in 2 digits>');
						readln(aStudent.SoutTime.hour);
						write('type in minute in 2 digits>');
						readln(aStudent.SoutTime.minute);
						writeln('ID# ', aStudent.key, ' signed out at ', aStudent.SoutTime.hour : 2, ':', aStudent.SoutTime.minute : 2);
						timeOut := aStudent.SoutTime.hour * 60 + aStudent.SoutTime.minute;
						timeIn := aStudent.SinTime.hour * 60 + aStudent.SinTime.minute;
						if timeOut < timeIn then
							timeOut := timeOut + 1440;
						aStudent.remHr := aStudent.remHr - (timeOut - timeIn);
						if aStudent.remHr < 0 then
							begin
								aStudent.penalty := true;
								aStudent.validity := false;
							end;		{if rem<0 then}
						aStudent.usdHr := aStudent.usdHr + (timeOut - timeIn);
						aStudent.atstatus := false;
						ModifyElement(List, aStudent);
					end		{if aStudent.astatus then}
				else
					begin
						writeln('ID# ', aStudent.key, ' did not sign in yet');
					end;		{if aStudent.astatus else}
			end		{if there then}
		else
			begin
				writeln('ID# ', aStudent.key, ' does not exists');
			end;		{if there else}
	end;		{signOut}
{***********************************}

	procedure Sign (var List: ListType);
		var
			choice, doneChoice: char;
			done: boolean;
	begin
		done := false;
		while not done do
			begin
				write('Sign: signIn, signOut,Exit>');
				readln(choice);
				case choice of
					'I': 
						SignIn(List);
					'O': 
						SignOut(List);
					'E': 
						done := true;
				end;		{case choice of}
				write('done?:Yes,No>');
				readln(doneChoice);
				if (doneChoice = 'y') or (doneChoice = 'Y') then
					done := true;		{if not Y,y then repeat}
			end;		{while not done}
	end;		{Sign}
{***********************************************}

	procedure WReList (var List: ListType);
		var
			Tptr: PointerType;
	begin
		if EmptyList(List) then
			writeln('no one is on the list.')
		else
			begin
				Tptr := List;
				writeln('the process of reinitializing list weekly has began....');
				writeln(' weekly reset..................');
				while Tptr <> nil do
					begin
						Tptr^.info.validity := true;
						if Tptr^.info.penalty then
							Tptr^.info.usdHr := 120
						else
							Tptr^.info.usdHr := 0;		{if Tptr^.info.penalty else}
						Tptr^.info.remHr := Tptr^.info.maxHr - Tptr^.info.usdHr;
						Tptr^.info.penalty := false;
						writeln('ID# ', Tptr^.info.key : 5, ' has been reset...');
						Tptr := Tptr^.next;
					end;		{while Tptr<>nil do}
				writeln('' : 5, '{ ......................................................the end of weekly reset ..}');
			end;		{if emptylist(list) else}
	end;		{ReList}
{***************************************************************}
end.				{Ledit}