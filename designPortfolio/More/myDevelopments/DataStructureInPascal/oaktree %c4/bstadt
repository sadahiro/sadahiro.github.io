unit BSTADT;
{Programmer:	Makoto Sadahiro }
{starting date: Dec 11th '93}
{last modified date:  Dec 11th '93}

{Binary Search Tree Abstract Data Type}

interface
	uses
		bstType;
	type
		TreePtrType = ^TreeNodeType;
		TreeNodeType = record
				Info: TreeElementType;
				Left: TreePtrType;
				Right: TreePtrType;
			end;
		TreeType = TreePtrType;
{*************************************}

	procedure CreateTree (var Tree: TreeType);
	procedure RetrieveElement (Tree: TreeType;
									KeyValue: KeyType;
									var Element: TreeElementType;
									var ValueInTree: Boolean);
	procedure ModifyElement (var Tree: TreeType;
									ModElement: TreeElementType);
	procedure InsertElement (var Tree: TreeType;
									Element: TreeElementType);
	procedure DeleteElement (var Tree: TreeType;
									KeyValue: KeyType);
	procedure PrintNode (Element: TreeElementType);
	procedure PrintInorder (Tree: TreeType);
	procedure PrintPreorder (Tree: TreeType);
	procedure PrintPostorder (Tree: TreeType);
	procedure DestroyTree (var Tree: TreeType);
{*************************************}

implementation

	procedure CreateTree (var Tree: TreeType);

  (* Initializes Tree to empty state. *)

	begin (* CreateTree *)
		Tree := nil
	end;  (* CreateTree *)
{*************************************}
      { HIDDEN  PROCEDURE }

	procedure FindNode (Tree: TreeType;
									KeyValue: KeyType;
									var NodePtr: TreePtrType;
									var ParentPtr: TreePtrType);

  (* Find the node that contains KeyValue; set NodePtr to    *)
  (* point to the node and ParentPtr to point to its parent; *)

		var
			Found: Boolean;  (* KeyValue found in tree? *)

	begin (* FindNode *)

  (* Set up to search. *)
		NodePtr := Tree;
		ParentPtr := nil;
		Found := False;

  (* Search until no more nodes to search or until found. *)
		while (NodePtr <> nil) and not Found do
			if NodePtr^.Info.Key = KeyValue then
				Found := True

			else (* Advance pointers. *)
				begin

					ParentPtr := NodePtr;

					if NodePtr^.Info.Key > KeyValue then
						NodePtr := NodePtr^.Left
					else
						NodePtr := NodePtr^.Right

				end (* advance pointers *)
	end; (* FindNode *)
{*************************************}

	procedure RetrieveElement (Tree: TreeType;
									KeyValue: KeyType;
									var Element: TreeElementType;
									var ValueInTree: Boolean);

  (* Searches the binary search tree for the element whose *)
  (* key is KeyValue, and returns a copy of the element.   *)

		var
			NodePtr: TreePtrType; (* pointer to node with KeyValue *)
			ParentPtr: TreePtrType; (* used for FindNode interface   *)

	begin (* RetrieveElement *)

  (* Find node in tree that contains KeyValue. *)
		FindNode(Tree, KeyValue, NodePtr, ParentPtr);

		ValueInTree := (NodePtr <> nil);

		if ValueInTree then
			Element := NodePtr^.Info

	end;  (* RetrieveElement *)
{*************************************}

	procedure ModifyElement (var Tree: TreeType;
									ModElement: TreeElementType);

  (* ModElement replaces existing tree element with same key. *)
		var
			NodePtr: TreePtrType; (* pointer to node with KeyValue *)
			ParentPtr: TreePtrType; (* used for FindNode interface   *)

	begin (* ModifyElement *)

  (* Find the node with the same key as ModElement.Key. *)
		FindNode(Tree, ModElement.Key, NodePtr, ParentPtr);

  (* NodePtr points to the tree node with same key. *)
		NodePtr^.Info := ModElement

	end;  (* ModifyElement *)
{*************************************}

	procedure InsertElement (var Tree: TreeType;
									Element: TreeElementType);

  (* Add Element to the binary search tree. Assumes that no *)
  (* element with the same key exists in the tree.          *)

		var
			NewNode: TreePtrType;  (* pointer to new node         *)
			NodePtr: TreePtrType;  (* used for FindNode call      *)
			ParentPtr: TreePtrType;  (* points to new node's parent *)

	begin (* InsertElement *)

  (* Create a new node. *)
		New(NewNode);
		NewNode^.Left := nil;
		NewNode^.Right := nil;
		NewNode^.Info := Element;

  (* Search for the insertion place. *)
		FindNode(Tree, Element.Key, NodePtr, ParentPtr);

  (* IF this is first node in tree, set Tree to NewNode; *)
  (* otherwise, link new node to Node(ParentPtr).        *)
		if ParentPtr = nil then
			Tree := NewNode  (* first node in the tree *)
		else (* Add to the existing tree. *)
			if ParentPtr^.Info.Key > Element.Key then
				ParentPtr^.Left := NewNode
			else
				ParentPtr^.Right := NewNode

	end; (* InsertElement *)
{*************************************}

	procedure DeleteElement (var Tree: TreeType;
									KeyValue: KeyType);

  (* Deletes the element containing KeyValue from the binary *)
  (* search tree pointed to by Tree. Assumes that this key   *)
  (* value is known to exist in the tree.                    *)

		var
			NodePtr: TreePtrType; (* pointer to node to be deleted    *)
			ParentPtr: TreePtrType; (* pointer to parent of delete node *)
{***************************}
			{Nested Procedures}

		procedure FindAndRemoveMax (var Tree: TreePtrType;
										var MaxPtr: TreePtrType);

		begin (* FindAndRemoveMax *)

			if Tree^.Right = nil then (* Base Case: maximum found *)
				begin
					MaxPtr := Tree;       (* return pointer to max node *)
					Tree := Tree^.Left  (* unlink max node from tree  *)
				end (* Base Case *)

			else (* General Case: find and remove from right subtree *)
				FindAndRemoveMax(Tree^.Right, MaxPtr)

		end;  (* FindAndRemoveMax *)
{****************************}

		procedure DeleteNode (var NodePtr: TreePtrType);

  (* Deletes the node pointed to by NodePtr from the binary *)
  (* search tree. NodePtr is a real pointer from the parent *)
  (* node in the tree, not an external pointer.             *)

			var
				TempPtr: TreePtrType;  (* node to delete *)

		begin  (* DeleteNode *)

  (* Save the original pointer for freeing the node. *)
			TempPtr := NodePtr;

  (* Case of no children or one child: *)
			if NodePtr^.Right = nil then
				NodePtr := NodePtr^.Left

			else (* There is at least one child. *)
				if NodePtr^.Left = nil then (* There is one child. *)
					NodePtr := NodePtr^.Right

				else (* There are two children. *)
					begin
            (* Find and remove the replacement value from *)
            (* Node(NodePtr)'s left subtree.              *)
						FindAndRemoveMax(NodePtr^.Left, TempPtr);

            (* Replace the delete element. *)
						NodePtr^.Info := TempPtr^.Info

					end; (* There are two children. *)

  (* Free the unneeded node. *)
			Dispose(TempPtr)

		end;  (* DeleteNode *)
{****************************}

	begin (* DeleteElement *)

  (* Find node containing KeyValue. *)
		FindNode(Tree, KeyValue, NodePtr, ParentPtr);

  (* Delete node pointed to by NodePtr. ParentPtr points  *)
  (* to the parent node, or is NIL if deleting root node. *)
		if NodePtr = Tree then (* Delete the root node. *)
			DeleteNode(Tree)
		else if ParentPtr^.Left = NodePtr then (* Delete the left child node. *)
			DeleteNode(ParentPtr^.Left)
		else (* Delete the right child node. *)
			DeleteNode(ParentPtr^.Right)

	end;  (* DeleteElement *)
{*************************************}

	procedure PrintNode (Element: TreeElementType);

	begin (* PrintNode  *)
		writeln('name- ', Element.key);
		writeln('major- ', Element.major);
		writeln('living status simbol- ', Element.living);
		writeln;
	end;  (* PrintNode *)
{*****************}

	procedure PrintInorder (Tree: TreeType);

  (* Prints out the elements in a binary search tree in *)
  (* order from smallest to largest. This procedure is  *)
  (* a recursive solution.                              *)

	begin  (* PrintInorder *)

  (* Base Case: If Tree is NIL, do nothing. *)
		if Tree <> nil then

			begin (* General Case *)

        (* Traverse left subtree to print smaller values. *)
				PrintInorder(Tree^.Left);

        (* Print the information in this node. *)
				PrintNode(Tree^.Info);
        (* Traverse right subtree to print larger values. *)
				PrintInorder(Tree^.Right)

			end (* General Case *)
	end; (* PrintInorder *)
{*************************}

	procedure PrintPreorder (Tree: TreeType);

  (* Print out the elements in a binary search tree in *)
  (* preorder. This procedure is a recursive solution. *)

	begin (* PrintPreorder *)

  (* Base Case: IF Tree is NIL, do nothing. *)
		if Tree <> nil then (* General Case *)
			begin

        (* Print the value of this node. *)
				PrintNode(Tree^.Info);

        (* Traverse the left subtree in preorder. *)
				PrintPreorder(Tree^.Left);

        (* Traverse the left subtree in preorder. *)
				PrintPreorder(Tree^.Right)

			end  (* General Case *)
	end; (* PrintPreorder *)
{*************************}

	procedure PrintPostorder (Tree: TreeType);

  (* Prints out the elements in a binary search tree in *)
  (* postorder. This procedure is a recursive solution. *)

	begin (* PrintPostorder *)

  (* Base Case: If Tree is NIL, do nothing. *)
		if Tree <> nil then (* General Case *)
			begin

        (* Traverse the left subtree in postorder. *)
				PrintPostorder(Tree^.Left);

        (* Traverse the right subtree in postorder. *)
				PrintPostorder(Tree^.Right);

        (* Print the value of this node. *)
				PrintNode(Tree^.Info)

			end (* General Case *)
	end; (* PrintPostorder *)
{*************************************}

	procedure DestroyTree (var Tree: TreeType);

  (* Removes all the elements from the binary search tree *)
  (* rooted at Tree, leaving the tree empty.              *)

	begin (* DestroyTree *)

  (* Base Case: If Tree is NIL, do nothing. *)
		if Tree <> nil then (* General Case *)
			begin

        (* Traverse the left subtree in postorder. *)
				DestroyTree(Tree^.Left);

        (* Traverse the right subtree in postorder. *)
				DestroyTree(Tree^.Right);

        (* Delete this leaf node from the tree. *)
				Dispose(Tree);

			end (* General Case *)
	end; (* DestroyTree *)
{*************************************}
end. (* unit *)