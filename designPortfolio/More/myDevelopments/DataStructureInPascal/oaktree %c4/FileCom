unit FileCom;
{Programmer:	Makoto Sadahiro }
{starting date: Dec 11th '93}
{last modified date:  Dec 12th '93}

{FileCom is series of file commands for Oak Tree}
interface
	uses
		IFaceUtil, IOOC, bstType, bstadt;

{loads up data of text file to tree}
	procedure LoadTree (var myTree: TreeType);
	{does close text after data is transfered to tree}
{saves data on tree into text}
	procedure SaveTree (var myTree: TreeType);
	{SaveTree will only save.  it does not distroy tree}
{shutDown routine}
	procedure ShutDown (var myTree: TreeType);
	{shutDown will not save tree.  it asks if user want to save}
	{it will distroy tree at the end}
{*************************************}
implementation

{GetTextFile will open up source text file}
	procedure GetTextFile (var myText: Text);
	{out: text}
	{pre: text file does not exists}
	{post: text file exists}
		var
			myTextName: str255;
	begin
		OpenFileIN(myText, myTextName);
		writeln('following file opened');
		writeln(myTextName);
	end;		{GetTextFile}
{************************}

{Treerize will load data from text file to tree}
	procedure Treerize (var myTree: TreeType;
									var myText: text);
	{in: text}
	{out: tree}
	{pre: tree is empty}
	{post: tree has information transfered from text}
		var
			stuNode, nodeCopy: TreeElementType;
			there: boolean;
	begin
		while not eof(myText) do
			begin
				readln(myText, stuNode.key);
				readln(myText, stuNode.major, stuNode.living);
				RetrieveElement(myTree, stuNode.key, nodeCopy, there);
				if not (there) then
					Insertelement(myTree, stuNode)
				else
					writeln('the same name found. name can not over rided-new data ignored');
			end;		{while not eof do}
	end;		{Treerize}
{************************}

	procedure LoadTree (var myTree: TreeType);
		var
			myText: text;
	begin
		GetTextFile(myText);
		Treerize(myTree, myText);
		writeln('data loading done.');
		CloseFile(myText);
	end;		{LoadTree}
{*************************************}

{CreateOutText will open text file for as output}
	procedure CreateOutText (var myText: text);
	{out: text file with empty status}
	{pre: text file does not exists}
	{post: text file exists with empty status}
		var
			myOutTextName: str255;
	begin
		OpenFileOUT(myText, myOutTextName);
		writeln('following output file created');
		writeln(myOutTextName);
	end;		{CreateOutText}
{************************}

{Filerize will write information on tree onto text file}
	procedure Filerize (var myTree: TreeType;
									var myText: text);
	{in: tree}
	{out: text}
	{pre: text file is empty}
	{post: text file is filled with informaiton}
		var
			first, second: str255;
	begin
		if myTree <> nil then
			begin
				writeln(mytext, myTree^.info.key);
				writeln(mytext, myTree^.info.major, ' ', myTree^.info.living);
				Filerize(myTree^.Left, myText);
				Filerize(myTree^.Right, myText);
			end;
	end;		{Filerize}
{************************}

	procedure SaveTree (var myTree: TreeType);
		var
			myText: text;
	begin
		CreateOutText(myText);
		Filerize(myTree, myText);
		CloseFile(myText);
		writeln('data saving onto output file done.');
	end;		{SaveTree}
{*************************************}

	procedure ShutDown (var myTree: TreeType);
		var
			save: char;
			savedone: boolean;
	begin
		savedone := false;
		while not savedone do
{will keep asking user if one want to save till user input is valid}
			begin
				writeln('do you want to save?/Y,N');
				readln(save);
				case save of
					'Y', 'y': 
						begin
							SaveTree(myTree);
							savedone := true;
						end;		{Y,y}
					'N', 'n': 
						begin
							writeln('quiting WITHOUT saving has been chosen');
							savedone := true;
						end;		{N,n}
				end;		{case save of}
			end;		{while not savedone do}
		writeln('Exit application...click mouse to continue....');
		DestroyTree(myTree);
		Wait;
	end;		{ShutDown}
{*************************************}

{*************************************}
end.		{FileCom}